/*Транспонирование матрицы - это операция, после которой столбцы прежней матрицы становятся строками, а строки - столбцами. Напишите функцию транспонирования матрицы.

В функции main() пользователь вводит количество строк, количество столбцов и начальное значение генератора. Затем создается двумерный массив и инициализируется случайными числами от -10 до 15.

Исходный массив выводится на консоль в виде таблицы, при этом элементы в строке отделяются знаками табуляции (табуляция должна быть и после последнего элемента строки).

Затем выполняется транспонирование матрицы и преобразованная матрица вновь выводится на консоль. Между выводом исходной матрицы и преобразованной вставьте пустую строку.

Внимание! Не достаточно просто распечатать матрицу в транспонированном виде. Она должна в таком виде существовать в памяти! Представьте, что с ней будут проводится какие-то дальнейшие преобразования.

Каждое действие с двумерным массивом (инициализация, печать, транспонирование) оформите отдельной функцией, вызываемой из main().*/
#include <iostream>
#include <cstdlib>

using namespace std;

void initAr(int** ar, int r, int c)
{
	for (int i = 0; i < r; i++)
	{
		for (int j = 0; j < c; j++)
		{
			ar[i][j] = rand() % 26 - 10;
		}
	}
	return;
}

void printAr(int** ar, int r, int c)
{
	for (int i = 0; i < r; i++)
	{
		for (int j = 0; j < c; j++)
		{
			cout << ar[i][j] << "\t";
		}
		cout << endl;
	}
	return;
}

void restrAr(int**& ar, int& r, int& c)
{
	int** nAr = new int* [c];
	for (int i = 0; i < c; i++)
	{
		nAr[i] = new int[r];
	}

	for (int i = 0; i < c; i++)
	{
		for (int j = 0; j < r; j++)
		{
			nAr[i][j] = ar[j][i];
		}
	}

	for (int i = 0; i < r; i++)
	{
		delete[] ar[i];
	}
	delete[] ar;

	ar = nAr;
	int tmp = r;
	r = c;
	c = tmp;
	return;
}

int main() {
	int r, c, x;

	cin >> r >> c >> x;
	srand(x);

	int** ar = new int* [r];
	for (int i = 0; i < r; i++)
	{
		ar[i] = new int[c];
	}

	initAr(ar, r, c);
	printAr(ar, r, c);
	restrAr(ar, r, c);
	cout << endl;
	printAr(ar, r, c);

	for (int i = 0; i < r; i++)
	{
		delete[] ar[i];
	}
	delete[] ar;

	return 0;
}